package com.ctk.ignite.config;

import java.sql.*;
import java.util.*;

import org.apache.ignite.cache.*;
import org.apache.ignite.cache.store.jdbc.*;
import org.apache.ignite.configuration.*;

/**
 * CacheConfig definition.
 *
 * Code generated by Apache Ignite Schema Import utility: 08/16/2016.
 */
public class PersonCacheConfig {
    /**
     * Create JDBC type for person.
     *
     * @param cacheName Cache name.
     * @return Configured JDBC type.
     */
    private static JdbcType jdbcTypePerson(String cacheName) {
        JdbcType jdbcType = new JdbcType();

        jdbcType.setCacheName(cacheName);
        jdbcType.setDatabaseSchema("ignite");
        jdbcType.setDatabaseTable("person");
        jdbcType.setKeyType("com.ctk.vo.PersonKey");
        jdbcType.setValueType("com.ctk.vo.Person");

        // Key fields for person.
        Collection<JdbcTypeField> keys = new ArrayList<>();
        keys.add(new JdbcTypeField(Types.INTEGER, "id", int.class, "id"));
        jdbcType.setKeyFields(keys.toArray(new JdbcTypeField[keys.size()]));

        // Value fields for person.
        Collection<JdbcTypeField> vals = new ArrayList<>();
        vals.add(new JdbcTypeField(Types.VARCHAR, "first_name", String.class, "firstName"));
        vals.add(new JdbcTypeField(Types.VARCHAR, "last_name", String.class, "lastName"));
        vals.add(new JdbcTypeField(Types.DOUBLE, "salary", double.class, "salary"));
        jdbcType.setValueFields(vals.toArray(new JdbcTypeField[vals.size()]));

        return jdbcType;
    }

    /**
     * Create SQL Query descriptor for person.
     *
     * @return Configured query entity.
     */
    private static QueryEntity queryEntityPerson() {
        QueryEntity qryEntity = new QueryEntity();

        qryEntity.setKeyType("com.ctk.vo.PersonKey");
        qryEntity.setValueType("com.ctk.vo.Person");

        // Query fields for person.
        LinkedHashMap<String, String> fields = new LinkedHashMap<>();

        fields.put("id", "java.lang.Integer");
        fields.put("firstName", "java.lang.String");
        fields.put("lastName", "java.lang.String");
        fields.put("salary", "java.lang.Double");

        qryEntity.setFields(fields);

        // Aliases for fields.
        Map<String, String> aliases = new HashMap<>();

        aliases.put("firstName", "first_name");
        aliases.put("lastName", "last_name");

        qryEntity.setAliases(aliases);

        // Indexes for person.
        Collection<QueryIndex> idxs = new ArrayList<>();

        idxs.add(new QueryIndex("id", true, "PRIMARY"));

        qryEntity.setIndexes(idxs);

        return qryEntity;
    }

    /**
     * Configure cache.
     *
     * @param cacheName Cache name.
     * @param storeFactory Cache store factory.
     * @return Cache configuration.
     */
    public static <K, V> CacheConfiguration<K, V> cache(String cacheName, CacheJdbcPojoStoreFactory<K, V> storeFactory) {
        if (storeFactory == null)
             throw new IllegalArgumentException("Cache store factory cannot be null.");

        CacheConfiguration<K, V> ccfg = new CacheConfiguration<>(cacheName);

        ccfg.setCacheStoreFactory(storeFactory);
        ccfg.setReadThrough(true);
        ccfg.setWriteThrough(true);

        // Configure JDBC types. 
        Collection<JdbcType> jdbcTypes = new ArrayList<>();

        jdbcTypes.add(jdbcTypePerson(cacheName));

        storeFactory.setTypes(jdbcTypes.toArray(new JdbcType[jdbcTypes.size()]));

        // Configure query entities. 
        Collection<QueryEntity> qryEntities = new ArrayList<>();

        qryEntities.add(queryEntityPerson());

        ccfg.setQueryEntities(qryEntities);

        return ccfg;
    }
}
